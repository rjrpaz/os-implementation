<html xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./Assign3SampleSolution_files/filelist.xml">
<title>Synopsis:</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Stankass</o:Author>
  <o:Template>Normal</o:Template>
  <o:LastAuthor>hawkey</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>5</o:TotalTime>
  <o:Created>2003-07-03T11:32:00Z</o:Created>
  <o:LastSaved>2003-07-03T11:32:00Z</o:LastSaved>
  <o:Pages>5</o:Pages>
  <o:Words>1120</o:Words>
  <o:Characters>6388</o:Characters>
  <o:Company>dal</o:Company>
  <o:Lines>53</o:Lines>
  <o:Paragraphs>12</o:Paragraphs>
  <o:CharactersWithSpaces>7844</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal>Synopsis:</p>

<p class=MsoNormal>There are two independent processes, the main game process
and the background loading process.<span style="mso-spacerun: yes">  </span>The
purpose behind having two processes is to maximize the CPU utilization, such
that the main process can do other things (ie. manipulate data, creating, and
calculating) while the background process is focused on the loading.</p>

<p class=MsoNormal>In order to manage concurrency accordingly, implementation
of synchronization schemes between these two processes must exist to protect
the data that is shared between them.<span style="mso-spacerun: yes"> 
</span>Therefore, the main task of this particular assignment is to synchronize
the two processes, maximize the CPU efficiency and maintain the requirements of
mutual exclusion, progress and bounded waiting.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Solution:</p>

<p class=MsoNormal>The pending queue and the completed queue store the requests
and they are separate from each other.<span style="mso-spacerun: yes"> 
</span>They are shared between the main process and the background
process.<span style="mso-spacerun: yes">  </span>The main process places
requests to the pending queue, and removes requests form the completed
queue.<span style="mso-spacerun: yes">  </span>Conversely, the background process
removes the requests form the pending queue and stores the completed requests
in the completed queue.</p>

<p class=MsoNormal>Therefore, synchronization needs to take place at two
different junctions for both queues, so that only one process may operate on
the specific queue at the same time.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Synchronization was achieved by implementing two sets of
three counting semaphores, each set used to guard one queue.<span
style="mso-spacerun: yes">  </span>This helped achieve mutual exclusion since
the semaphores mutexPending and mutexCompleted ensure that only one process at
the time can act on the given queue.<span style="mso-spacerun: yes"> 
</span>For both processes to act on the same queue at the same time, semaphores
mutexPending or mutexCompleted would have to have count values greater than
one, which is impossible in our implementation format.</p>

<p class=MsoNormal>With respect to progress condition, our implementation
guarantees progress since deadlock cannot occur.<span style="mso-spacerun:
yes">  </span>This is due to the fact that neither process will be waiting
indefinitely on the other process because for deadlock to occur one of the
queues would have to have at least one item and no items, which is
impossible.<span style="mso-spacerun: yes">  </span>An example of this is
demonstrated: the main process is waiting on &lt;wait(emptyPending)&gt; that is
waiting for at least one free space in the pending queue, while at the same
time the loading process is waiting for the wait(mul_NumAsyncRequests) that is
for at least one item to be in the pending queue, obviously this condition can
not exist.<span style="mso-spacerun: yes">  </span>With respect to the
completed queue the similar situation exists but the main and loading processes
swap roles of producer and consumer respectively. </p>

<p class=MsoNormal>As far as bounded waiting condition is concerned it is
satisfied for both processes as a consequence of both queues being bounded
buffers.<span style="mso-spacerun: yes">  </span>It is impossible for one
process to dominate and continuously prevent the other process form having a
chance to execute.<span style="mso-spacerun: yes">  </span>This can be
demonstrated by the following example, of the worst case scenario.<span
style="mso-spacerun: yes">  </span>If the bound on the buffer is 1000 the
producer (either main or the loading process) will be able to produce at most
1000 requests to the queue before it will be forced to wait for the consumer to
consume at least one item.</p>

<p class=MsoNormal>With respect to CPU utilization the solution above maximizes
the CPU effieciency since the loading process will only get to execute when an
item exists in the pending queue and the main process will only call to
CFILE::Service() when an item exists in the completed queue.<span
style="mso-spacerun: yes">  </span>These two constraints limit the wasted CPU
time and allow the main process to focus on getting more done hence making it
more efficient. </p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Note:</p>

<p class=MsoNormal>Our solution to the problem was predominately based on the
May 30, 2003 in-class handout pertaining to Producer/Consumer Bounded
Buffer(solution).<span style="mso-spacerun: yes">  </span>Where the actual was
implemented, however, using different variable names. </p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style='font-size:14.0pt;mso-bidi-font-size:12.0pt'>Pseudocode
of solution:<o:p></o:p></span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Initialization of shared data:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>semaphore
mutexPending, mul_NumAsyncRequests, emptyPending;</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>semaphore
mutexCompleted, mul_NumCompletedAsyncRequests, </p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>emptyCompleted;</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>Queue<span
style='mso-tab-count:1'>            </span>pending, completed;</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>// mutual exclusion
for the pending queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>mutexPending.count:=1;</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>// number of filled
spaces in the pending queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> 
</span>mul_NumAsyncRequests.count:=0;</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>// number of empty
spaces in the pending queue (k = BUFSIZ)</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> 
</span>emptyPending.count:=k;</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>// mutual exclusion
for the completed queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> 
</span>mutexCompleted.count:=1;</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>// number of filled
spaces in the completed queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> 
</span>mul_NumCompletedAsyncRequests:=0;</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>// number of empty
spaces in the completed queue (k = BUFSIZ)</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> 
</span>emptyCompleted.count:=k;</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>Main:</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>repeat</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Create
Read/Write/Seek request</p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>CAsyncFileRequest
= CFile::Create(Read or Write or Seek);</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Wait for
pending queue to have a free space</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   
</span>wait(emptyPending);<span style='mso-tab-count:1'>    </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes"> </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Wait for
mutexPending to equal one, then decrement</p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// mutexPending
and enter the CS</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   
</span>wait(mutexPending);<span style='mso-tab-count:1'>    </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes"> </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Append
CAsyncFileRequest to pending queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   
</span>pending.store(CAsyncFileRequest);</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Increment
mutex now that process is not in CS</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   
</span>signal(mutexPending);<span style='mso-tab-count:1'>  </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Signal that a
request has been added to the pending queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   
</span>signal(mul_NumAsyncRequests);</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Perform other
operations. Manipulate textures, create</p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// game
environment, perform calculations, etc.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// If the
completed queue is empty, skip this section because</p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>//
synchronization of the two processes is not necessary</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span><span
style="mso-spacerun: yes">  </span>if (mul_NumCompletedAsyncRequests &gt; 0) {</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">      </span>// Call
CFile::Service() to remove item from completed queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes">     
</span>completedRequest = CFile::Service();</p>

<p class=MsoNormal><span style="mso-spacerun: yes">      </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">      </span>// Manipulate
data that was just loaded, etc.</p>

<p class=MsoNormal><span style="mso-spacerun: yes">     
</span>doSomethingTo(completedRequest);</p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span><span
style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">      </span>// Call
AsyncOperationComplete() on callback object</p>

<p class=MsoNormal><span style="mso-spacerun: yes">     
</span>AsyncOperationComplete();<span style='mso-tab-count:1'>    </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>}</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>forever</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal>Loading:</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>repeat</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Wait for a
request to be placed in the pending queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   
</span>wait(mul_NumAsyncRequests);</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Decrement
mutexPending and enter CS</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   
</span>wait(mutexPending);<span style='mso-tab-count:1'>    </span></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Retrieve a
CAsyncFileRequest from the pending queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>item =
pending.retrieve();</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Increment
mutexPending to indicate that process has left CS</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   
</span>signal(mutexPending);</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Signal that
another space has freed up in the pending queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   
</span>signal(emptyPending);</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Perform the
file operation on the request that was just removed</p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// from the
pending queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>requestResult =
ExecuteAsyncFileOperation(item);</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Wait for
completed queue to have a free space</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   
</span>wait(emptyCompleted);</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Wait for
mutexCompleted to equal one, then decrement </p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// mutexCompleted
and enter the CS. Basically, this process is</p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// synchronizing
with the main process to make sure that the</p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// main process
in not operating on the completed queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   
</span>wait(mutexCompleted);</p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Storing the
completed request into the completed queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   
</span>completed.store(requestResult);</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Indicate that
process is no longer in CS. mutexCompleted has been</p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// incremented.</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   
</span>signal(mutexCompleted);</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">    </span>// Indicate that
an item has been added to the completed queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes">   
</span>signal(mul_NumCompletedAsyncRequests);</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>forever</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal>CFile::Service:</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>// decrement
mul_NumCompletedAsyncRequests</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> 
</span>wait(mul_NumCompletedAsyncRequests);</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>// Wait for
mutexCompleted to equal one, then decrement mutexCompleted</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>// and enter the CS</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> 
</span>wait(mutexCompleted);</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>// Retrieving a
completed request from the completed queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>result =
completed.retrieve();</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>// Increment
mutexCompleted to indicate that process is no longer in CS</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> 
</span>signal(mutexCompleted);</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>// Signal that
another space has been freed up in completed queue</p>

<p class=MsoNormal><span style="mso-spacerun: yes"> 
</span>signal(emptyCompleted);</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>return result;</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span></p>

<p class=MsoNormal>Queue Methods:</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>store(item):</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>buf[in]:=item;</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>in=(++in)mod k;</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal>retrieve:</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>item:=b[out];</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>out=(++out)mod k;</p>

<p class=MsoNormal><span style="mso-spacerun: yes">  </span>return item;</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

</div>

</body>

</html>
