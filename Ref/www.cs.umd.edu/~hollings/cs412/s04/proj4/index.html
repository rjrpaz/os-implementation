<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>CMSC 412 - Project 4</title>
</head>
<body lang="EN-US" link="blue" vlink="purple">
<center><font size="+2"><b>CMSC 412 Project #4</b> </font></center>
<p>
</p>
<center><font size="+1"><b>Paging</b>
</font></center>
<center>
<p><b>Due Thursday, April 8th, 2004
(9:00 AM)</b></p>
</center>
<li><b><a href="p4_grading.html">Grading Criteria</a> </b>
</li>
<li><b><a href="submission.html">Submission Instructions</a> </b>
<li><b>Recitation material: <a href="proj4.ppt">proj4.ppt</a></b>

  <h2>New project files</h2>
</li>
<p>
<li>In .bochsrc change the line <tt>diskc: file=hd.img, cyl=64, heads=4, spt=16</tt> to <tt> diskc: file=hd.img, cyl=64, heads=16, spt=16</tt>
<li>In the Makefile, under hd.img change the line <tt>$(ZEROFILE) $@ 4096</tt> to <tt>$(ZEROFILE) $@ 16384</tt>
<li><b><a href="paging.h">paging.h</a></b> and <b><a href="paging.c">paging.c</a></b>
- add to the project directory; add paging.c to the Makefile in the project directory
<li><b><a href="mem.h">mem.h</a></b> and <b><a href="mem.c">mem.c</a></b>
- replace old versions
<li><b><a href="Makefile.user.add">Makefile.user.add</a></b> add to Makefile in userProgs
<p>
<li><b><a href="rec.c">rec.c</a></b> - save in your <b>userProgs</b> <br>
  <br>
  <h1>Introduction</h1>
  <p>The purpose of this project is to add paging to your project. This
will require many small, but difficult changes to your project. More
than any previous project, it will be important to implement one thing,
test it and then move to the next one. </p>
  <h1>Changing the Project to Use Page Tables</h1>
  <p>The first step is to modify your project to use page directories and page tables and
segmentation rather than just segments to provide memory protection. To
begin using page directories, every region of memory your access (both
kernel and data segment) must have an entry in a page directory and table. 
The way
this will work is that there will be a single page directory for all kernel
only threads, and a page directory for each user process. In addition, the
page directory for user mode processes will also contain entries to
address the kernel mode memory. The memory layout for this is shown
below. </p>
  <br>
  <br>
  <table style="text-align: left; width: 50%;" border="0"
 cellspacing="2" cellpadding="2">
    <tbody>
      <tr>
        <td style="vertical-align: top;">VA 0x0000 0000</td>
        <td style="vertical-align: top;">Kernel Memory</td>
        <td style="vertical-align: top;">
        <p style="page-break-after: avoid;" class="MsoNormal">Start of
kernel memory</p>
        <p style="page-break-after: avoid;" class="MsoNormal">(map all
physical memory here)</p>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">VA 0x8000 0000</td>
        <td style="vertical-align: top;">User Memory</td>
        <td style="vertical-align: top;">Data/Text start here<br>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;"><br>
        </td>
        <td style="vertical-align: top;"><br>
&lt;gap&gt;<br>
        <br>
        </td>
        <td style="vertical-align: top;"><br>
        </td>
      </tr>
      <tr>
        <td style="vertical-align: top;">VA 0xFFFF E000</td>
        <td style="vertical-align: top;">User Memory</td>
        <td style="vertical-align: top;">Initial stack at top of this page</td>
      </tr>
      <tr>
        <td style="vertical-align: top;">VA 0xFFFF F000</td>
        <td style="vertical-align: top;">User Memory</td>
        <td style="vertical-align: top;">Args in this page</td>
      </tr>
      <tr>
        <td style="vertical-align: top;"><font size=-1>VA 0xFFFF FFFF</font></td>
        <td style="vertical-align: top;">&nbsp</td>
        <td style="vertical-align: top;"><font size=-1>Memory space ends here</font></td>
      </tr>
    </tbody>
  </table>
  <br>
  <p>The kernel memory should be a one to one mapping of all of the
physical memory in the processor (this limits the physical memory of
the processor to 2GB, but this is not a critical limit for this
project). The page directory/table entries for this memory should be marked so
that this memory is only accessible from kernel mode (i.e. the userMode
bit in the page directory and page table should be 0). To make this
change, you should start by creating a page directory and page table
entries for the kernel threads by writing a function that initializes
the page tables and enables paging mode in the processor. 
You can easily do this  in <tt>mem.c</tt>, in the function <tt>Init_Mem</tt>.
</p>
  <p>To setup page tables, you will need to allocate a page directory
(via <tt>Alloc_Page</tt>) and then allocate page tables for the entire region
that will be mapped into this memory context. You will need to fill out
the appropriate fields in the page tables and page directories.
The definition of paging tables and directories are to be found in 
<tt>paging.h</tt> (structs <tt>pageTableEntry</tt> and <tt>pageDirectoryEntry</tt>).
Finally, to enable paging for the first time, you will need to call
the routine <tt>Enable_Paging(pdbr)</tt> which is already defined for you in 
<tt>lowlevel.asm</tt>. It takes the base address
of your page directory as a parameter. 

You should be able to do this step and test it by itself (by
temporarily giving user mode access to the kernel pages - set the 
<tt>userMode</tt> field to 1).</p>

  <p>The next step is to modify your user processes to all use pages in
the
user region. This is a two-step process. First, you need to allocate a
page directory for this user space. You should copy all of the
entries from the kernel page directory you've set up in <tt>Init_Mem</tt>. 
(This makes interrupt handling easy because you don't have
to change the page tables when you switch back and forth).
</p>
<p>
Next you need to allocate page table
entries for the user processes text and data regions. 
When you create the executable image don't include space for the stack
(but do round to PAGE_SIZE, though). Allocate (a page at a time)
as many pages as needed to hold the executable image. Then copy
the image, page by page into the newly allocated pages.
Do not forget to add an entry for each newly allocated page in your process'
s page table. 
</p>
<p>
Finally, you should allocate space for
two pages of memory at the end of the virtual address range (i.e.
the last two entries in the last page table). One is for the 
parameters, the other one is for stack.
For the user space page
mappings, make sure to enable the <tt>userMode</tt> bits in both the page
directory and page table entries.</p>
  <p>You will also need to change some aspects of how the code from
project
#2 sets things up. The base address for the user mode process should be
0x8000 0000, and the limit should be 0xFFFF FFFF. This will allow the
user space process to think that its virtual location 0 is the 2GB
point in the page layout and will greatly simplify your kernel compared
to traditional paged systems. You will also need to add code to switch
the PDBR register. For this, in <tt>Activate_User_Context_C</tt>
you should add a call to <tt>setPDBR</tt>
(provided for you in <tt>lowlevel.asm</tt>) as part of a context switch, 
after you load the LDT. Of course, you will add a field in the userContext 
structure that will store the address of the process's page directory).</p>

  <p>You will also need to create a second version of <tt>Alloc_Page</tt> (in
<tt>mem.c</tt>).
This version should be called <tt>Alloc_Pageable_Page</tt>. The primary
difference is that any page allocated by this routine should have a
special flag PAGE_PAGEABLE set in the flags field of its entry in the
struct Page data structure (see mem.h). All pages (but not page
directories and page tables) for a user space process should be
allocated using this routine. </p>

<p>At this point, you should be able to run programs again.</p>

  <h1>Handling Page Faults</h1>
  <p>One of the key features of using paging is to have the operating
system handle page faults. To do this you will need to write a page
fault interrupt handler. The first thing the page fault handler will
need to do is to figure out the address of the page fault. It will then
need to determine an appropriate action to take. Possible reasons for a
page fault, and the action to take are shown in the table below. </p>
  <br>
  <table cellpadding="2" cellspacing="2" border="1"
 style="text-align: left; width: 50%;">
    <tbody>
      <tr>
        <td style="vertical-align: top;"><b>Cause</b></td>
        <td style="vertical-align: top;"><b>Indication</b></td>
        <td style="vertical-align: top;"><b>Action</b></td>
      </tr>
      <tr>
        <td style="vertical-align: top;">Stack growing to new page</td>
        <td style="vertical-align: top;">Fault is within one page of
the current stack limit</td>
        <td style="vertical-align: top;">Allocate a new page and
continue.</td>
      </tr>
      <tr>
        <td style="vertical-align: top;">Fault for paged out page</td>
        <td style="vertical-align: top;">Bits in page table indicate
page is on disk</td>
        <td style="vertical-align: top;">Read page from paging device
(sector indicated in PTE) and continue.</td>
      </tr>
      <tr>
        <td style="vertical-align: top;">Fault for invalid address</td>
        <td style="vertical-align: top;">None of the other conditions
apply</td>
        <td style="vertical-align: top;">Terminate user process</td>
      </tr>
    </tbody>
  </table>
  <br>
<p><tt>paging.c</tt> already provides you with an empty page fault handler
(<tt>PageFault_Handler</tt>).
You need to register this as a handler for interrupt 14 in <tt>trap.c</tt>.
In order to test the page fault handler, run the provided program <tt>rec.c</tt>.
</p>

  <p>The fault handler reads register cr2 to determine the 
faulting address. It also prints the errorCode field defined in
the struct <tt>pageFaultErrorCode</tt> in <tt>paging.h</tt> 
</p>

  <h1>Paging Out Pages</h1>
  <p>At some point, your operating system will run out of pages
to assign to processes. In this case, you will need to pick a page to
evict from memory and write it to the backing store (paging file). You
should implement a version of pseudo-LRU (see section 10.4.4 in textbook). Use the reference bit in the
page tables to keep track of how frequently pages are accessed. To do
this, use the clock field in the struct <tt>Page</tt> in <tt>mem.h</tt>. 
You should update the clock on every page fault.</p>
  <p>You will also need to manage the use of the paging file. The
paging file consists of a group of consecutive 512 bytes disk blocks.
Calling the routine getPagingFileInfo function in pfat.c, will return
the first disk block number of the paging file and the number of disk
blocks in the paging file. Each page will consume 8 consecutive disk
blocks. To read/write the paging file, use the functions IDE_Read and
IDE_Write.</p>
  <p>When a page is paged out, you will need to update the page table
entry for that page to clear the valid bit. You will probably want to
put the first disk block that contains the page into the pageBaseAddr
field of the page table. The kernelInfo bits (3 bits holding a number
from 0-7) can be used to indicate that the page is on disk rather than
not valid. You should also invalidate the TLB as part of the page out
operation. Although the x86 processor supports a selective invalidate,
you can invalidate the entire TLB for this project. Any move to cr3
(the PDBR) will flush the TLB. To do this, use the
routine <tt>flushTLB</tt> provided in <tt>lowlevel.asm</tt>
</p>
  <h1>Page Ins</h1>
  <p>When you bring a page in off disk, you may discard its disk
version (i.e. free the disk space used by the page). This will simplify
your paging system, but will require that when a page is removed from
memory it must always be written to the backing store (since even clean
pages no longer have a version on disk).</p>
  <h1>Process Termination</h1>
  <p>As part of process termination, you will need to free the memory
associated with a process. This includes freeing the pages used
by the process, freeing the page tables and page directories. In
addition, you will need to release the backing store space used by any
pages of the terminating process.</p>
</li>
  <script language="JavaScript">
          <!---//hide script from old browsers
          var theDate = new Date(document.lastModified);
          var theLocalDate = theDate.toLocaleString();
          document.write( "<i>Last updated: "+ theLocalDate +"</i><hr>");
          //end hiding contents --->
  </script>
</body>
</html>
