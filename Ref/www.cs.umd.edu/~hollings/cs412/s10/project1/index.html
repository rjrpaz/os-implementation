<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns:st1="urn:schemas-microsoft-com:office:smarttags"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=File-List href="project1_files/filelist.xml">
<title>CMSC 412, Spring 2010</title>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="place"/>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="City"/>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>hollings</o:Author>
  <o:Template>Normal</o:Template>
  <o:LastAuthor>Jeff Hollingsworth</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>1</o:TotalTime>
  <o:LastPrinted>2010-01-26T16:58:00Z</o:LastPrinted>
  <o:Created>2010-02-05T14:19:00Z</o:Created>
  <o:LastSaved>2010-02-05T14:19:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>2288</o:Words>
  <o:Characters>13043</o:Characters>
  <o:Company>University of Maryland</o:Company>
  <o:Lines>108</o:Lines>
  <o:Paragraphs>30</o:Paragraphs>
  <o:CharactersWithSpaces>15301</o:CharactersWithSpaces>
  <o:Version>11.9999</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:View>Print</w:View>
  <w:Zoom>110</w:Zoom>
  <w:SpellingState>Clean</w:SpellingState>
  <w:GrammarState>Clean</w:GrammarState>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:Compatibility>
   <w:SelectEntireFieldWithStartOrEnd/>
   <w:UseWord2002TableStyleRules/>
   <w:UseFELayout/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]--><!--[if !mso]><object
 classid="clsid:38481807-CA0E-42D2-BF39-B33AF135CC4D" id=ieooui></object>
<style>
st1\:*{behavior:url(#ieooui) }
</style>
<![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
@font-face
	{font-family:"MS Mincho";
	panose-1:2 2 6 9 4 2 5 8 3 4;
	mso-font-alt:"Arial Unicode MS";
	mso-font-charset:128;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 134676480 16 0 131072 0;}
@font-face
	{font-family:"\@MS Mincho";
	panose-1:0 0 0 0 0 0 0 0 0 0;
	mso-font-charset:128;
	mso-generic-font-family:roman;
	mso-font-format:other;
	mso-font-pitch:fixed;
	mso-font-signature:1 134676480 16 0 131072 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"MS Mincho";
	mso-fareast-language:JA;}
h1
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	mso-outline-level:1;
	font-size:24.0pt;
	font-family:"Times New Roman";
	mso-fareast-language:JA;
	font-weight:bold;}
h2
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	mso-outline-level:2;
	font-size:18.0pt;
	font-family:"Times New Roman";
	mso-fareast-language:JA;
	font-weight:bold;}
h3
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	mso-outline-level:3;
	font-size:13.5pt;
	font-family:"Times New Roman";
	mso-fareast-language:JA;
	font-weight:bold;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;
	text-underline:single;}
p
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"MS Mincho";
	mso-fareast-language:JA;}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"MS Mincho";
	mso-fareast-language:JA;}
tt
	{font-family:"Courier New";
	mso-ascii-font-family:"Courier New";
	mso-fareast-font-family:"MS Mincho";
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Courier New";}
span.SpellE
	{mso-style-name:"";
	mso-spl-e:yes;}
span.GramE
	{mso-style-name:"";
	mso-gram-e:yes;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in .5in 1.0in .5in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:65763098;
	mso-list-template-ids:130455260;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l1
	{mso-list-id:117338986;
	mso-list-template-ids:-631861876;}
@list l1:level1
	{mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l2
	{mso-list-id:130948927;
	mso-list-template-ids:-1153809320;}
@list l2:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l3
	{mso-list-id:509833948;
	mso-list-template-ids:1321483426;}
@list l3:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l4
	{mso-list-id:536158335;
	mso-list-template-ids:-1068485160;}
@list l4:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l5
	{mso-list-id:665980083;
	mso-list-template-ids:-1293646410;}
@list l5:level1
	{mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l6
	{mso-list-id:951208345;
	mso-list-template-ids:1231832730;}
@list l6:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l7
	{mso-list-id:1025668922;
	mso-list-template-ids:-1758193476;}
@list l7:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l8
	{mso-list-id:1150556051;
	mso-list-template-ids:440196290;}
@list l8:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l8:level2
	{mso-level-number-format:bullet;
	mso-level-text:o;
	mso-level-tab-stop:1.0in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:"Courier New";
	mso-bidi-font-family:"Times New Roman";}
@list l9
	{mso-list-id:1173034665;
	mso-list-template-ids:-120530268;}
@list l9:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l10
	{mso-list-id:1285960133;
	mso-list-template-ids:985974434;}
@list l10:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l11
	{mso-list-id:1726568464;
	mso-list-template-ids:873654638;}
@list l11:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l12
	{mso-list-id:1736121091;
	mso-list-template-ids:-473658626;}
@list l12:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l13
	{mso-list-id:1746103649;
	mso-list-template-ids:-638320312;}
@list l13:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
@list l14
	{mso-list-id:2014843532;
	mso-list-template-ids:1780141002;}
@list l14:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:10.0pt;
	font-family:Symbol;}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
table.MsoTableGrid
	{mso-style-name:"Table Grid";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	border:solid windowtext 1.0pt;
	mso-border-alt:solid windowtext .5pt;
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-border-insideh:.5pt solid windowtext;
	mso-border-insidev:.5pt solid windowtext;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="2050"/>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=EN-US link=blue vlink=purple style='tab-interval:.5in'>

<div class=Section1>

<h1 align=center style='margin:0in;margin-bottom:.0001pt;text-align:center'><span
style='font-size:12.0pt;font-weight:normal'>CMSC 412, <span class=GramE>Spring</span>
2010<o:p></o:p></span></h1>

<h1 align=center style='margin:0in;margin-bottom:.0001pt;text-align:center'><span
style='font-size:14.0pt'>Project 1<br>
Due: Friday, February 19th, 2010 6:00 pm<o:p></o:p></span></h1>

<h2><span style='font-size:14.0pt'>Overview<o:p></o:p></span></h2>

<p class=MsoNormal><span style='font-size:10.0pt'>In this project we will be
augmenting the <span class=SpellE>GeekOS</span> process services to include (1)
<i>background</i> processes, (2) being able to kill a process asynchronously
from another process, and (3) being able to view the currently running
processes and their status.<o:p></o:p></span></p>

<h3>Links</h3>

<ul type=disc>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo6;tab-stops:list .5in'><span class=SpellE><span
     style='font-size:10.0pt'>svn</span></span><span style='font-size:10.0pt'>
     co https://svn.cs.umd.edu/repos/geekos/project1 (or <span class=SpellE>svn</span>
     update)<o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo6;tab-stops:list .5in'><span style='font-size:10.0pt'><a
     href="http://www.intel.com/products/processor/manuals/index.htm">The IA-32
     Intel(R) Architecture Software Developer's <span class=SpellE>Manual,Volume</span>
     3</a><o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo6;tab-stops:list .5in'><span style='font-size:10.0pt'>Submissions:
     run &quot;make <span class=SpellE>submission.zip</span>&quot; and upload.
     (<span class=GramE>remove</span> the file if needed to re-submit.)<o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l0 level1 lfo6;tab-stops:list .5in'><span style='font-size:10.0pt'><a
     href="http://www.cs.umd.edu/class/spring2010/cmsc412/project1/grading.html">Grading</a><o:p></o:p></span></li>
</ul>

<h2><span style='font-size:14.0pt'>Preliminaries <o:p></o:p></span></h2>

<p class=MsoNormal><span style='font-size:10.0pt'>We will first provide some
background on process lifetimes in <span class=SpellE>GeekOS</span>, and some
more details on how system calls are implemented. The project requirements are
presented bellow. Following the requirements, we present further background
material on how process address spaces are implemented, many details of which
are not important for this project, but will be more important for project 4
(so it might be useful to understand at least some of them now).<o:p></o:p></span></p>

<h3>Process Creation and Termination</h3>

<p class=MsoNormal><span style='font-size:10.0pt'>As you already know, a user
process in <span class=SpellE>GeekOS</span> is essentially a <span
class=SpellE>Kernel_Thread</span> with an attached <span class=SpellE>User_Context</span>.
Each <span class=SpellE>Kernel_Thread</span> has a field </span><tt><span
style='font-size:10.0pt'>alive</span></tt><span style='font-size:10.0pt'> that
indicates whether it has terminated (e.g., whether <span class=GramE>Exit(</span>)
has been called). In addition, a <span class=SpellE>Kernel_Thread</span> has a <span
class=SpellE>refCount</span> field that is used to indicate the number of
kernel threads interested in this thread. When a thread is alive, its <span
class=SpellE>refCount</span> is always at least 1, which indicates its own
reference to itself. If a thread for a process is started via <span
class=SpellE>Start_User_Thread</span> with a </span><span style='font-size:
10.0pt;font-family:"Courier New"'>detached</span><span style='font-size:10.0pt'>
argument of &quot;false&quot;, then the <span class=SpellE>refCount</span> will
be 2: one self-reference plus a reference from the owner. When </span><span
style='font-size:10.0pt;font-family:"Courier New"'>detached</span><span
style='font-size:10.0pt'> is false, the </span><span style='font-size:10.0pt;
font-family:"Courier New"'>owner</span><span style='font-size:10.0pt'> field in
the new <span class=SpellE>Kernel_Thread</span> object is initialized to point
to the <span class=SpellE>Kernel_Thread</span> spawning it (aka the <i>parent</i>).&nbsp;
Typically, the parent of a new process is the shell process that spawned it.<br>
<br>
The parent-child relationship is useful when the parent wants to retrieve the
returned result of the new process using the <span class=GramE>Wait(</span>)
system call. For example, in the shell (<span class=SpellE>src/user/shell.c</span>),
if <span class=SpellE>Spawn_Program</span> is successful, the shell waits for
the newly launched process to terminate by calling <span class=GramE>Wait(</span>),
which returns the child process's exit code. The Wait system call is
implemented by using thread queues, which we explain below.<br>
<br>
When a process terminates by calling Exit, it detaches itself, removing its
self-reference. Moreover, when the parent calls Wait, it removes the other
reference, bring <span class=SpellE>refCount</span> to 0. When this is the
case, the Reaper process is able to destroy the thread, discarding its <span
class=SpellE>Kernel_Thread</span> object. Any process that is dead, but has not
been reaped, is called a zombie. The reasons for this could be many, one
instance being the parent failing to release its <span class=SpellE>refCount</span>:
bug or otherwise. <o:p></o:p></span></p>

<h3>More about process lifetimes: Zombies </h3>

<p class=MsoNormal><span style='font-size:10.0pt'>A process can be in one of
four states on its way from being alive to being dead: <o:p></o:p></span></p>

<ol start=1 type=1>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo7;tab-stops:list .5in'><span class=SpellE><span
     style='font-size:10.0pt'>refCount</span></span><span style='font-size:
     10.0pt'>=0, alive=false <o:p></o:p></span></li>
</ol>

<p style='margin-left:.5in'><span style='font-size:10.0pt'>This process is a
zombie that's &quot;totally dead,&quot; as the child has done Exit to reduce
its <span class=SpellE>refCount</span>, and if it had a parent at all, it
reduced its <span class=SpellE>refCount</span> too. Thus, the process will soon
be reaped. <o:p></o:p></span></p>

<ol start=2 type=1>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo7;tab-stops:list .5in'><span class=SpellE><span
     style='font-size:10.0pt'>refCount</span></span><span style='font-size:
     10.0pt'>=1, alive=false <o:p></o:p></span></li>
</ol>

<p style='margin-left:.5in'><span style='font-size:10.0pt'>The process has
called <span class=GramE>Exit(</span>), but the parent hasn't called Wait(). In
this case, the process is also a zombie, but is not on the graveyard queue. <o:p></o:p></span></p>

<ol start=3 type=1>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo7;tab-stops:list .5in'><span class=SpellE><span
     style='font-size:10.0pt'>refCount</span></span><span style='font-size:
     10.0pt'>=1, alive=true <o:p></o:p></span></li>
</ol>

<p style='margin-left:.5in'><span style='font-size:10.0pt'>The process is a
background process, and is alive and well. <o:p></o:p></span></p>

<ol start=4 type=1>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l1 level1 lfo7;tab-stops:list .5in'><span class=SpellE><span
     style='font-size:10.0pt'>refCount</span></span><span style='font-size:
     10.0pt'>=2, alive=true <o:p></o:p></span></li>
</ol>

<p style='margin-left:.5in'><span style='font-size:10.0pt'>The process is a
&quot;foreground&quot; process, and is alive and well. <o:p></o:p></span></p>

<h3>Thread Queues</h3>

<p class=MsoNormal><span style='font-size:10.0pt'>As processes enter the
system, they are put into a <i>job queue</i>. In particular, the processes that
are residing in the main memory and are ready and waiting to execute are kept
on a list called the <i>run queue</i>.&nbsp; It stays there, not executing,
until it is selected for execution. Once the process is allocated the CPU and
is executing, one of several events can occur: <o:p></o:p></span></p>

<ul type=disc>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l11 level1 lfo8;tab-stops:list .5in'><span style='font-size:10.0pt'>The
     process could issue an I/O request and then be placed in an <i>I/O queue</i>.
     For example, suppose the process makes an I/O to a shared device, such as
     a disk. Since there may be many processes in the system, the disk may be
     busy with the I/O request of some other process. The process therefore may
     have to wait for the disk. The list of processes waiting for a particular
     device is called the device queue. Each device has its own <i>device queue</i>.
     <o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l11 level1 lfo8;tab-stops:list .5in'><span style='font-size:10.0pt'>The
     process could create a new <span class=SpellE>subprocess</span> and Wait
     for the <span class=SpellE>subprocesses</span> termination. In which case
     it goes into the wait queue for that process (which is defined in the <span
     class=SpellE>Kernel_Thread</span> <span class=SpellE>struct</span>) by
     calling the <span class=GramE>join(</span>) routine in <span class=SpellE>kthread.c</span>.<o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l11 level1 lfo8;tab-stops:list .5in'><span style='font-size:10.0pt'>The
     process could be removed forcibly from the CPU, as a result of a timer
     interrupt, and be put back in the run queue. <o:p></o:p></span></li>
</ul>

<p><span style='font-size:10.0pt'>In the first two cases, the process
eventually switches from the waiting state to the ready state and is then
removed from its I/O queue and put back in the run queue. A process continues
this cycle until it terminates, at which time it is not present on any queue.<o:p></o:p></span></p>

<h3>System Calls</h3>

<p><span style='font-size:10.0pt'>Sometimes a program will need to interact
with the system in ways that require it to access other memory, or otherwise
perform privileged operations. For example, if the program wants to write to
the screen, it may need to access video memory, which will be outside of the
process's segment. Or it may need to use privileged instructions, such as I/O
instructions, that only the OS can perform on its behalf.&nbsp; <o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>The operating system therefore provides a
series of <i>System Calls</i>, also known as <span class=SpellE><i>Syscalls</i></span>,
which are routines that carry out some operation for the user process that
calls it. But since these routines are themselves in protected memory, the OS
provides a special mechanism for making <span class=SpellE>syscalls</span>.<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>In order to make a <span class=SpellE>syscall</span>
in <span class=SpellE>GeekOS</span>, a user program sends a processor
interrupt, using the </span><span class=SpellE><span style='font-size:10.0pt;
font-family:"Courier New"'>int</span></span><span style='font-size:10.0pt'>
instruction. <span class=SpellE>GeekOS</span> has provided an interrupt handler
that is installed as interrupt 0x90. This routine, called <span class=SpellE>Syscall_Handler</span>
(<span class=SpellE>src/geekos/trap.c</span>), examines the current value in
the register <span class=SpellE>eax</span> and calls the appropriate system
routine to handle the <span class=SpellE>syscall</span> request. The value in <span
class=SpellE>eax</span> is called the <span class=SpellE>Syscall</span> Number.
The routine that handles the <span class=SpellE>syscall</span> request is
passed a copy of the caller's context state, stored in <span class=SpellE>struct</span>
<span class=SpellE>Interrupt_State</span>, so the values in general registers (<span
class=SpellE>ebx</span>, <span class=SpellE>ecx</span>, <span class=SpellE>edx</span>)
can be used by the user program to pass parameters to the handler routine and
can be used to return values to the user program.<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>The <span class=SpellE>syscall</span>
routines are defined in <span class=SpellE>src/geekos/syscall.c</span>: <span
class=SpellE>Sys_Null</span>, <span class=SpellE>Sys_Exit</span>, etc. In
general, <span class=SpellE>syscall</span> routines will do the following: <o:p></o:p></span></p>

<ul type=disc>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l12 level1 lfo9;tab-stops:list .5in'><span style='font-size:10.0pt'>Extract
     any parameters passed by the user process. These are passed in the
     registers, and are saved in the user context passed to the system call.
     They can be accessed via state-&gt;<span class=SpellE>ebx</span>,
     state-&gt;<span class=SpellE>ecx</span>, etc.<o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l12 level1 lfo9;tab-stops:list .5in'><span style='font-size:10.0pt'>Implement
     the logic of the <span class=SpellE>syscall</span> <o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l12 level1 lfo9;tab-stops:list .5in'><span style='font-size:10.0pt'>Return
     the result (or the appropriate error code) <o:p></o:p></span></li>
</ul>

<p><span style='font-size:10.0pt'>Before returning from the <span class=SpellE>syscall</span>,
some OS code must restore the user context so that the program can continue
running where it left off. A pointer to the stored copy of the context - on the
kernel stack - is actually what is passed to the <span class=SpellE>Syscall_Handler</span>.<o:p></o:p></span></p>

<p><i><span style='font-size:10.0pt'>Further <st1:City w:st="on"><st1:place
 w:st="on">Reading</st1:place></st1:City>:</span></i><span style='font-size:
10.0pt'> More information about system calls more generally can be found in
Chapter 2 of the text.<o:p></o:p></span></p>

<h2><a name=requirements></a><span style='font-size:14.0pt'>Project
Requirements<o:p></o:p></span></h2>

<p class=MsoNormal><span style='font-size:10.0pt'>There are three primary goals
of this project: <o:p></o:p></span></p>

<ul type=disc>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l13 level1 lfo10;tab-stops:list .5in'><span style='font-size:
     10.0pt'>Add &quot;background&quot; processes <o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l13 level1 lfo10;tab-stops:list .5in'><span style='font-size:
     10.0pt'>Support asynchronous killing of background processes. <o:p></o:p></span></li>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l13 level1 lfo10;tab-stops:list .5in'><span style='font-size:
     10.0pt'>Support printing the process table (i.e., information about the
     currently-running processes)<o:p></o:p></span></li>
</ul>

<h3>Add background processes</h3>

<p class=MsoNormal><span style='font-size:10.0pt'>As explained above, in order
for a process to be reaped, a parent must <span class=GramE>Wait(</span>) on
the child process's <span class=SpellE>pid</span>. However, there may be
situations in which the parent would like to let the child process just
complete on its own and die a graceful death, without having to <span
class=GramE>Wait(</span>) on it. To do this, we need a way to spawn a child
&quot;in the background,&quot; so that the parent can continue on with its
work, oblivious of what the newly spawned process is doing. To implement
background processes, do the following:<o:p></o:p></span></p>

<p style='margin-left:.5in;text-indent:-.25in;mso-list:l7 level1 lfo11;
tab-stops:list .5in'><![if !supportLists]><span style='font-size:10.0pt;
font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:Symbol'><span
style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><span style='font-size:10.0pt'>Modify the <span
class=SpellE>Sys_Spawn</span> system call to expect an additional argument from
the user process, which is whether to spawn in the <i>background</i> or not. <i>Remember--the
Sys_* functions take only one argument, an <span class=SpellE>Interrupt_State</span>,
so if you want to pass another argument, you'll need to modify the macro
defining the system call to put another value into the registers before INT
0x90 is called.</i> A background process is one that starts life detached;
i.e., it has no parent, and thus its <span class=SpellE>refCount</span> starts
at 1. In addition, a background process, <i>and <span class=GramE>all of its</span>
child processes (even if spawned as &quot;foreground&quot; processes)</i>,
should not be allowed to read input characters. In particular, the <span
class=SpellE>GetKey</span> system call should fail, returning -1. In turn, the <span
class=SpellE>Read_Line</span> library routine callable from user programs
should return -1 if it fails to get a key. The shell should be modified to
handle this possibility (since it calls <span class=SpellE>Read_Line</span>). A
parent process will not be able to <span class=GramE>Wait</span> on any process
it spawns in the background; the <span class=SpellE>Sys_Wait</span> system call
will return -1 (or some more descriptive/appropriate negative value) in this
case. Note, however, that there is no restriction on background processes
spawning, and waiting on, foreground processes (which according to the
above-mentioned restriction should not be able to read input).<o:p></o:p></span></p>

<p style='margin-left:.5in;text-indent:-.25in;mso-list:l7 level1 lfo11;
tab-stops:list .5in'><![if !supportLists]><span style='font-size:10.0pt;
font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:Symbol'><span
style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><span style='font-size:10.0pt'>Modify the <span
class=SpellE>src/user/shell.c</span> to handle forking processes in the
background. Modify the code to parse a command to look for '&amp;' as the last
character, and if so, adjust the call to <span class=GramE>Spawn(</span>)
accordingly. Finally, the shell should print [PID] after it spawns a background
process, where PID is the process ID of the spawned process. For example, a
background spawn of the process &quot;null.exe&quot; at the shell would look
something like the following: <o:p></o:p></span></p>

<pre style='margin-left:.5in'>$ null.exe <span class=GramE>&amp;</span><br>
[10]<br>
$</pre>

<h3>Killing processes</h3>

<p class=MsoNormal><span style='font-size:10.0pt'>It could be that once a
background process, or any other process, starts to run, it may behave badly,
or the work it is performing may become irrelevant. Therefore, we would like to
have some way for one process to kill another process. To do this, do the
following:<o:p></o:p></span></p>

<p style='margin-left:.5in;text-indent:-.25in;mso-list:l3 level1 lfo12;
tab-stops:list .5in'><![if !supportLists]><span style='font-size:10.0pt;
font-family:Symbol;mso-fareast-font-family:Symbol;mso-bidi-font-family:Symbol'><span
style='mso-list:Ignore'>·<span style='font:7.0pt "Times New Roman"'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span></span></span><![endif]><span style='font-size:10.0pt'>Implement the <span
class=SpellE>Sys_<span class=GramE>Kill</span></span><span class=GramE>(</span>)
system call (a stub appears in <span class=SpellE>src/geekos/syscall.c</span>)
that takes a PID as its argument. The semantics are that the given process is
killed immediately. (Note that this is unsafe in a general setting, since that
process might hold shared resources, but there aren't any shared resources in <span
class=SpellE>GeekOS</span>. Wait until project 3!).<o:p></o:p></span></p>

<p style='margin-left:.5in'><span style='font-size:10.0pt'>This is different
from a thread calling <span class=GramE>Exit(</span>). Note that when a thread
is executing it is not in any queue and is only referenced in <span
class=SpellE>g_currentThread</span>. Therefore when doing the cleanup of a
thread that called Exit by itself it makes sense to not consider any queues.
But an asynchronous kill of a process can happen at any time. Particular
example scenarios are for instance when the process is waiting for its child
process to die and so is in the wait queue for that process. <span class=GramE>Or
when it is in the <span class=SpellE>runQueue</span> of the system.</span>
Therefore when doing this asynchronous kill you will need to ensure that you
properly remove the process from all queues it is in.&nbsp;<o:p></o:p></span></p>

<p style='margin-left:.5in'><span style='font-size:10.0pt'>Also consider what
should happen with a killed process's child processes: Their parent pointer is
now invalid, and so they should be adjusted accordingly. Indeed, the same thing
should happen for Exit, but does not in the implementation we provide---it
turns out that this field is not used by the child process after its parent
dies, so it can be left dangling. However, in your modified code, you will be
using the parent pointer to print the process table, so both Exit and Kill
should behave similarly, <span class=SpellE>nulling</span> the dangling parent
pointer.<o:p></o:p></span></p>

<p style='margin-left:.5in'><span style='font-size:10.0pt'>There is an
interesting design point here: if a parent dies and fails to <span class=GramE>Wait(</span>)
on its children, should we also decrement the children's <span class=SpellE>refCount</span>?
If this does not happen, the child will remain a zombie, so decrement the
counter.<o:p></o:p></span></p>

<p style='margin-left:.5in'><span style='font-size:10.0pt'>When determining
which processes can be killed; a process that falls in category II above (sec
&quot;More about process lifetimes: Zombies&quot;) should be allowed to be
killed. This would happen because a child has died but its parent has not yet
done a <span class=SpellE>Sys_Wait</span>, and we want <span class=SpellE>Sys_Kill</span>
to be able to clean up the system nonetheless. <o:p></o:p></span></p>

<ul type=disc>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l3 level1 lfo12;tab-stops:list .5in'><span style='font-size:10.0pt'>Add
     a <span class=SpellE>src/user/kill.c</span> user program. This should take
     one or more command-line arguments, each of which is a process PID, and
     invoke the Kill system call on each, returning 0 if all of the system
     calls succeed, or the result of the first system call that fails (the
     program must terminate at the first such failure). The Kill system call
     stub in user space has been defined for you; its prototype appears in
     include/<span class=SpellE>libc/process.h</span>. <o:p></o:p></span></li>
</ul>

<h3>Printing the process table</h3>

<p class=MsoNormal><span style='font-size:10.0pt'>Now that we can run many
processes from the shell at once, we might like to get a snapshot of the
system, to see what's going on.&nbsp; Therefore, you will implement a program
and a system call that prints the status of the threads and processes in the
system:<o:p></o:p></span></p>

<ul type=disc>
 <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto;
     mso-list:l6 level1 lfo13;tab-stops:list .5in'><span style='font-size:10.0pt'>Implement
     the system call <span class=SpellE>Sys_PS</span> that returns relevant
     information about the current processes. The user should pass a pointer to
     an array of <span class=SpellE>Process_Info</span> <span class=SpellE>structs</span>,
     along with the size of the array. These <span class=SpellE>structs</span>
     are defined as <o:p></o:p></span></li>
</ul>

<pre style='margin-left:.5in;tab-stops:45.8pt 63.0pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
class=SpellE><span class=GramE>struct</span></span> <span class=SpellE>Process_Info</span> {<br>
<span style='mso-spacerun:yes'>   </span><span style='mso-tab-count:1'>  </span>char name[128];<br>
<span style='mso-spacerun:yes'>    </span><span style='mso-tab-count:1'> </span><span
class=SpellE>int</span> <span class=SpellE>pid</span>;</pre><pre
style='margin-left:.5in;tab-stops:45.8pt 63.0pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
style='mso-tab-count:2'>     </span><span class=SpellE><span class=GramE>int</span></span> <span
class=SpellE>parent_pid</span>;<br>
<span style='mso-tab-count:1'>  </span><span style='mso-tab-count:1'>   </span><span
class=SpellE>int</span> priority;<br>
<span style='mso-tab-count:1'>  </span><span style='mso-tab-count:1'>   </span><span
class=SpellE>int</span> status;<br>
};</pre><pre style='margin-left:.5in'><o:p>&nbsp;</o:p></pre>

<p class=MsoNormal><span style='font-size:10.0pt'>Here, <span class=SpellE><span
class=GramE>pid</span></span> and <span class=SpellE>parent_pid</span> should
be self-explanatory. The &quot;name&quot; part comes from the program argument
to <span class=GramE>Spawn(</span>); for kernel processes this should be
&quot;{kernel}&quot; by default. The &quot;status&quot; field should be 0 for <span
class=SpellE>runnable</span> threads (<span class=SpellE>ie</span> threads that
are in the <span class=SpellE>runQueue</span> or actually running), 1 for
blocked (<span class=SpellE>ie</span> threads that are waiting on some I/O
queue, or the queue of a child process), and 2 for zombie (<span class=SpellE>ie</span>
threads that are no longer alive but have not yet been reaped). The proper
#defines for these, and the above <span class=SpellE>struct</span>, are set up
for you in include/<span class=SpellE>geekos/user.h</span>, which is included
from include/<span class=SpellE>libc/process.h</span>. Finally, priority is the
priority number of the process, with respect to scheduling. You can get this
information from the <span class=SpellE>Kernel_Thread</span> and <span
class=SpellE>User_Context</span> <span class=SpellE>structs</span>, though you
may need to augment them.<o:p></o:p></span></p>

<p><span style='font-size:10.0pt'>When printing out the status of the process,
it should be considered a zombie if it falls in category 1 or 2 above (in sec
&quot;More about process lifetimes: Zombies&quot;) ---that is, a process is a
zombie if the alive field is false. <o:p></o:p></span></p>

<p class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:auto'><span
style='font-size:10.0pt'>Add a <span class=SpellE>src/user/ps.c</span> user
program. This takes no arguments and should execute the <span class=SpellE>Sys_PS</span>
system call to extract the process information and print it out. For the status
field, print R for <span class=SpellE>runnable</span> or currently running, B
for blocked, and Z for zombie. Format the output as in the following: <o:p></o:p></span></p>

<pre style='margin-left:.5in'>PID PPID PRIO STAT COMMAND
<span style='mso-spacerun:yes'>  </span>1<span style='mso-spacerun:yes'>    </span>0<span style='mso-spacerun:yes'>    </span>1<span style='mso-spacerun:yes'>    </span>B {kernel}
<span style='mso-spacerun:yes'>  </span>2<span style='mso-spacerun:yes'>    </span>0<span style='mso-spacerun:yes'>    </span>1<span style='mso-spacerun:yes'>    </span>R {kernel}
<span style='mso-spacerun:yes'>  </span>3<span style='mso-spacerun:yes'>    </span>0<span style='mso-spacerun:yes'>    </span>1<span style='mso-spacerun:yes'>    </span>B {kernel}
<span style='mso-spacerun:yes'>  </span>4<span style='mso-spacerun:yes'>    </span>0<span style='mso-spacerun:yes'>    </span>1<span style='mso-spacerun:yes'>    </span>B {kernel}
<span style='mso-spacerun:yes'>  </span>5<span style='mso-spacerun:yes'>    </span>0<span style='mso-spacerun:yes'>    </span>1<span style='mso-spacerun:yes'>    </span>B {kernel}
<span style='mso-spacerun:yes'>  </span>6<span style='mso-spacerun:yes'>    </span>1<span style='mso-spacerun:yes'>    </span>1<s1an style='mso-spacerun:yes'>    </span>B /c/shell.exe
<span style='mso-spacerun:yes'>  </span>7<span style='mso-spacerun:yes'>    </span>0<span style='mso-spacerun:yes'>    </span>1<span style='mso-spacerun:yes'>    </span>B /c/forktest.exe
<span style='mso-spacerun:yes'>  </span>8<span style='mso-spacerun:yes'>    </span>7<span style='mso-spacerun:yes'>    </span>2<span style='mso-spacerun:yes'>    </span>R /c/null.exe
<span style='mso-spacerun:yes'>  </span>9<span style='mso-spacerun:yes'>    </span>7<span style='mso-spacerun:yes'>    </span>2<span style='mso-spacerun:yes'>    </span>R /c/null.exe
<span style='mso-spacerun:yes'> </span>10<span style='mso-spacerun:yes'>    </span>7<span style='mso-spacerun:yes'>    </span>2<span style='mso-spacerun:yes'>    </span>R /c/null.exe</pre>

<p class=MsoNormal><span style='font-size:10.0pt'><o:p>&nbsp;</o:p></span></p>

<p class=MsoNormal><span style='font-size:10.0pt'>The PS system call stub in
user space has been defined for you; its prototype appears in include/<span
class=SpellE>libc/process.h</span>. Your process table must have space for at
least 50 entries. Please use &quot;%3d %4d %4d %4c %s&quot; as the format
string to achieve the formatting in the table as shown. Failure to use the
format string may cause tests to fail.<o:p></o:p></span></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

</div>

</body>

</html>
