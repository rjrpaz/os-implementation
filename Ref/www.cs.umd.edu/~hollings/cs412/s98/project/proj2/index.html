<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>CMSC 412 - Project 2</TITLE>
<META NAME="doccomm" CONTENT="&lt;META name="description" value="Project Handout"&gt;&lt;META name="keywords" value="p2"&gt;&lt;META name="resource-type" value="document"&gt;&lt;META name="distribution" value="global"&gt;">
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff">

<P ALIGN="CENTER">CMSC 412</P>
<P ALIGN="CENTER">Project 2: Multiprogramming, Part I</P>
<B><P ALIGN="CENTER">Due: March 4, 1998</P>
<FONT FACE="Arial" SIZE=4><P><A NAME="SECTION00010000000000000000">Introduction</A></P>
</B></FONT><P>Multiprogramming is a technique in which the CPU switches between running multiple processes that are fully or partially in memory at the same time. In this project, you will implement a small, <I>non-preemptive</I> multiprogramming system for an IBM compatible PC. The kernel will support three system calls, as described below. You will demonstrate your implementation by running several concurrent processes.</P>
<B><FONT FACE="Arial" SIZE=4><P>Suggested File Names</P>
</B></FONT><P>These are suggested file names. Some of the files will be extended from the ones you wrote for project 1.</P>

<UL>
<LI><A HREF="cmsc412.c">cmsc412.c</A>, <A HREF="cmsc412.h">cmsc412.h</A><BR>
There has been a slight modification of <TT>Cprintf() </TT>. This function now calls <TT>Put_char() </TT>instead of <TT>putch() </TT>. This requires <TT>screen.h </TT>to be included since <TT>Put_char() </TT>is presumed to be defined in this file. You should get a new copy.<BR>
Also, look at <TT>Mod_int </TT>and use that instead of <TT>asm CLI </TT>and <TT>asm STI</TT>. </LI>
<B><LI>keyboard.c/keyboard.h</B> The keyboard interrupt handler goes here.</LI>
<B><LI>screen.c/screen.h</B> The screen handler, <TT>Put_char()</TT>, etc. </LI>
<B><LI>queue.c/queue.h</B> Queue related functions. </LI>
<LI><A HREF="codes.h">codes.h</A>: Also, from project 1.</LI>
<LI><A HREF="makefile">makefile</A>: Sample makefile.</LI>
<B><LI>kernel.c / </B><A HREF="kernel.h">kernel.h</A><B> </B>System calls, and <TT>System_service </LI>
</TT><LI><A HREF="main.c">main.c</A> New version of main for this project.</LI>
<LI><A HREF="proc.c">proc.c</A> Sample proc.c used to test. You should write your own versions as well (for testing your code). </LI></UL>

<B><FONT FACE="Arial" SIZE=4><P><A NAME="SECTION00020000000000000000">Technical Description</A></P>
</FONT><I><FONT FACE="Arial"><P><A NAME="SECTION00021000000000000000">Processes</A></P>
</B></I></FONT><P>In this project, a process will execute the code of a C function. Sample process code can be found in <TT>proc.c</TT>. You will compile the kernel (in <TT>kernel.c</TT>) and user processes (in <TT>proc.c</TT>) separately, but link them together. This means that if you pass the name of the function (which is a function pointer), the kernel will know the address of this function. If the kernel and user process code had not been linked, then the kernel would not be able to resolve the addreses.</P>
<P>Each process will have useful information concerning the process kept in a PCB (process control block), which is a data structure. A PCB will be created during the initialization of a new process. You will need to determine what information the PCB structure should hold by reading this description carefully.</P>
<P>During its lifetime, a process can go through many states. For this project, a process is either running, or it ready to run. At most one process can be running at any given time. Normally, a process can also exist in other states (blocked, terminated, etc.), but you only have to concern yourself with the two states mentioned.</P>
<P>To indicate which state a process is in, you will place the PCB associated with a given process on a queue associated with the state of the process. For example, if a process is currently running, its PCB will be in the run queue. Since at most one process can be running at any given time, at most one PCB can be in the run queue. The run queue should be implemented as a pointer to a PCB. It should be noted that the run queue is not a true queue (i.e., there's no real enqueueing or dequeueing) despite its name.</P>
<P>If a process is not running, then it is ready to run. Processes that are ready to run have their PCBsa in the ready queue (which <I>is</I> a queue). When the running process yields, the PCB on the run queue will be removed and then enqueued onto the ready queue. A new PCB will then be dequeued from the ready queue and placed on the run queue, and that process will be activated. Selecting a new PCB from the ready queue and placing it on the run queue will be the responsibility of the function, <TT>Scheduler</TT>.</P>
<B><I><FONT FACE="Arial"><P><A NAME="SECTION00022000000000000000">System Calls</A></P>
</B></I></FONT><P>A <I>system call</I> is a request for an operating systems service. Each system call carries out some specific task. Your kernel will support three system calls:</P><DIR>

<CODE><P>int  Proc_start(int (*proc)(), int argc, char **argv)<BR>
void Proc_term()<BR>
void Yield()</P></DIR>

</CODE><FONT FACE="Arial"><P>Proc_start </P>
</FONT><P>Imagine you entered the following in your favorite shell. What would happen?</P><DIR>

<PRE>% a.out foo bar<BR>
   </PRE></DIR>

<P>The shell (whch is a user-level program) would parse this input. In particular, it would determine that there are three arguments. The shell would create an array of pointers to strings. In this case, the array would contain three pointers which would point to the strings: "<TT>a.out</TT>", "<TT>foo</TT>", and "<TT>bar</TT>". We will call this array the "argv" array because these are the arguments that can be accessed from the argv array in the <TT>main()</TT> function of <TT>a.out</TT>.</P>
<P>The shell would then make a system call requesting that the kernel create a process from the <TT>a.out</TT> executable. At the very least, the shell should pass the following arguments to the system call: the number of arguments, and the "argv" array. While you will not write a shell, you will write the system call. This system call will be called <TT>Proc_start</TT>. Because there is no shell to read and parse a command line, you will need to hardcode the "argv" array as shown in the sample <TT>proc.c</TT>.</P>
<P>Among the many tasks that the kernel performs when initializing a new process, it must create a new copy of the "argv" array. This includes the array itself as well as the strings that the array points to. It must also set up the stack for the child process so that the child process can access "argc", the argument count, and "argv". This is similar to what happens in programs that you write. You are allowed to access argc and argv from main().</P>
<TT><P>Proc_start</TT> has three arguments. The first is the name of the function you wish the newly created process to run. Recall that in C, the name of a function is a pointer to that function's code. You will need to write the functions used as processes in <TT>proc.c</TT> (or use the ones provided). The second argument is the number of parameters in the argv array. This always has a value greater than or equal to 1, because the name of the command (e.g., <TT>a.out</TT>) is always the first <TT>argv</TT> parameter. In C, this parameter is commonly called "argc" for the argument count. The third argument is the <TT>argv</TT> array which was described earlier.</P>
<P>To illustrate, if you wanted to create a process that runs the function <TT>foo</TT> with arguments <TT>23</TT> and <TT>cat</TT>, you would create an array of three elements whose first element contains a pointer to the string ``<TT>foo</TT>'', whose second element is 23 converted to a string, and whose third element is the string, ``<TT>cat</TT>''. Use <TT>Safe_malloc()</TT> to allocate the space.</P>
<P>This array is then passed as the third argument to <TT>Proc_start()</TT>. <TT>Proc_start()</TT> will generate interrupt 0x62, which will invoke the kernel. Within the kernel, you will need to determine that <TT>Proc_start()</TT> was called, and then make a copy of the <TT>argv</TT> array for the new child process that is about to be created. There is a reason for making this copy.</P>
<P>In a protected environment, processes usually have distinct address spaces. In particular, a parent process can not access the addresses of a child process and vice versa (this is not true in DOS, because processes can access any address, there is no real mechanism to protect a range of memory addresses for a given process). The reason for doing so is to prevent processes from acting maliciously. One tenet of operating systems is that a process should not be able to (easily) interfere with another process, and writing into another process's address space constitutes interference.</P>
<P>Suppose the kernel did not copy the "argv" array, and the child process could somehow point to the parent's copy. If the parent process terminates, its copy of the array will be freed (processes that are terminated have its resources, including memory, freed). If the child process accessed this array, it could contain garbage. We assume that a child process is independent of the parent process, i.e., if a parent process terminates, the child continues to run.</P>
<TT><P>Proc_start</TT> should return the process ID of the newly created child process.</P>
<FONT FACE="Arial"><P>Proc_term </P>
</FONT><TT><P>Proc_term()</TT> terminates the current process. No arguments are passed. The kernel should free up memory used by the process (stack space, PCB, etc.) This is typically not called within the user program. See further on to see how <TT>Proc_term</TT> is actually used.</P>
<FONT FACE="Arial"><P>Yield </P>
</FONT><TT><P>Yield()</TT> is called when the running process wants to temporarily give up use of the CPU. The kernel will move the PCB from the run queue to the ready queue, then select a new PCB from the ready queue, place it in the run queue, and activate the new process. Note that only the running process can call <TT>Yield()</TT>. For this project, a process voluntarily yields control of the CPU by calling <TT>Yield()</TT>, otherwise, it will run until completion when it is trivially pre-empted. The next project will allow the kernel to forcibly preempt a process, and switch to a new one.</P>
<FONT FACE="Arial"><P>Implementing system calls </P>
</FONT><P>The various system calls are "implemented" as functions. However, the functions are very simple. They basically generate an interrupt. Specifically, a number identifying the specific system call is placed the AX register. Then, a software interrupt is called (say, 0x62). That's usually the entire function (return values should be placed in AX). The kernel code (which is hooked at interrupt 0x62) does most of the work.</P>
<P>Normally, either the process making the system call or the kernel code must save the state of the user process prior to executing kernel code, then restore the state upon completion. However, if you write the kernel routines in C using a Borland ``interrupt'' function, the CPU environment will be preserved automatically by the compiler.</P>
<P>What happens to the invoking process depends on which system call was made. For <TT>Yield()</TT>, the current state is saved, the address of a Dispatch function is pushed on the stack, the stack pointer (ss:sp) is saved in the running process's PCB, the PCB is moved to the ready queue, and the scheduler is invoked to select a new process to run. To restore a yielded process, you need to restore the stack pointer (the one saved in the PCB), and call <TT>RETF</TT>, which will call the Dispatch function which restores the state of the process, and starts it running again.</P>
<P>For <TT>Proc_start()</TT>, a new PCB and stack are created using <TT>Safe_malloc</TT>, a new unique process ID is generated for this process, the PCB is added to the ready queue, and its process ID is returned to the calling process by altering the <TT>_AX</TT> value in the calling process's preserved CPU context. Accessing the SAX parameter from the interrupt handler's argument list (to be discussed momentarily) will do this. Note: <TT>Proc_start()</TT> only creates a new process (and PCB) and places the PCB in the ready queue. It does not run this newly created process! The scheduler eventually handles this.</P>
<P>If the requested system call is <TT>Proc_term()</TT>, then the process is deactivated by removing its PCB from the run queue, then returning first its stack space, then its PCB to the memory pool via <TT>Safe_free</TT>. The "argv" array must also be freed. The CPU scheduler is then invoked to select a process from the ready queue to run next.</P>
<P>The stack for a <I>newly created</I> process will appear as follows (note: SP value is for a stack of size 2K = 0x400):</P><DIR>

<CODE><P>SP Value  Parameter              Description<BR>
03DA      dispatch offset        IP of dispatch() &lt;------- top of stack<BR>
03DC      dispatch segment       CS of dispatch()<BR>
03DE      BP                     initially 0<BR>
03E0      DI                          "<BR>
03E2      SI                          "          <BR>
03E4      DS                     same as _DS of main()<BR>
03E6      ES                     initially 0<BR>
03E8      DX                          "<BR>
03EA      CX                          "<BR>
03EC      BX                          "<BR>
03EE      AX                          "<BR>
03F0      process's offset       new process's IP<BR>
03F2      process's segment      new process's CS<BR>
03F4      flags                  include interrupt enable on (see modint)<BR>
03F6      proc_term offset       IP of proc_term<BR>
03F8      proc_term segment      CS of proc_term<BR>
03FA      argc                   "Parameters" to the<BR>
03FC      argv offset               new <BR>
03FE      argv segment                process<BR>
</P></DIR>

</CODE><P>Note: the stack looks as if <TT>Proc_term()</TT> called the new process; thus when the process finishes, it will automatically invoke <TT>Proc_term()</TT>. This is a rather interesting solution to the problem of ``How do you terminate a process that does not call <TT>Proc_term()</TT>?''. Set up the stack in such a way that it appears that <TT>Proc_term()</TT> called the function that is being passed to <TT>Proc_start()</TT>, and when that function complete, <TT>Proc_term()</TT> will execute. This will perform various cleanup duties needed to properly terminate a process.</P><DIR>

<FONT FACE="Courier New" SIZE=2><P>        MOV SP, BP<BR>
        POP     BP<BR>
</P></DIR>

</FONT><TT><P>Dispatch()</TT> is a function that uses the ``asm'' feature. Since every C function creates its own stack frame, you first have to destroy it by the following asm instructions:</P>
<P>Then pop off the registers (in the order shown above) and call the IRET instruction. </P>
<P>Note that the stack frame of any process on the ready queue will look similar to that shown above. In particular, the stack frame will contain the ``IP of dispatch()'' through ``flags'' fields.</P>
<P>The following code is an outline for the code that will be included in <TT>kernel.c</TT>. This file should include <TT>System_service</TT> plus all of the system calls avaiable to the user programs (<TT> Proc_start</TT>, <TT>Proc_term</TT>, and <TT>Yield</TT>) as well as the <TT>Dispatch()</TT> function all).</P>
<FONT FACE="Courier New" SIZE=2><P>&nbsp;</P><DIR>

</FONT><CODE><P>void interrupt<BR>
System_service( sbp, sdi, ssi, sds, ses, sdx, scx, sbx, sax,<BR>
      sip, scs, sflags, sbp2, sip2, scs2, proc, argc, argv )<BR>
<BR>
      /* Access to system service routines. Service type is<BR>
         to be passed in the AX register */<BR>
<BR>
unsigned int sbp,sdi,ssi,sds,ses,sdx,scx,sbx,sax,sip,scs,sflags,<BR>
      sds2,sbp2,sip2,scs2,argc ;<BR>
int (*proc)() ;<BR>
char ** argv ;<BR>
{<BR>
        type = sax;  /* the system call number is placed in AX */<BR>
        switch (type) {<BR>
<BR>
        case PROC_START: <BR>
                &lt;code for proc_start&gt;<BR>
                break;<BR>
<BR>
        case PROC_TERM:<BR>
                &lt;code for proc_term&gt;<BR>
                break;<BR>
<BR>
        case YIELD:<BR>
                geninterrupt(0x63);<BR>
                break;<BR>
        }<BR>
        return;<BR>
}<BR>
</P></DIR>

</CODE><P>For those of you who are interested, the difference between Borland 4.5 and earlier versions is that the register DS would be pushed after <TT>sflags</TT>. That is, after <TT>sflags</TT>, you would add <TT>sds2</TT>, then <TT>sbp2</TT>. However, it is assumed that you will use Borland 4.5 for this project.</P>
<P>It may seem odd that <TT>System_service()</TT>, which is basically an interrupt handler, has an argument list. After all, an interrupt is not called like a normal function with arguments passed. The above is really a trick. When <TT>Proc_start</TT> is called, and interrupt 0x62 generated, the stack will look exactly like the arguments being passed to <TT>System_service</TT> with <TT>sbp</TT> at the top of the stack, an <TT>argv</TT> at the bottom, and in the order listed as shown in the formal parameter list. This makes it easier to access arguments on the stack without having to calculate the locations of all the registers on the stack.</P>
<P>The following function is at vector 0x63:</P><DIR>

<CODE><P>void interrupt Yield_process() {<BR>
    /* all regs have already been saved because of void interrupt */<BR>
    /* push cs:ip of Dispatch() */<BR>
    /* save ss:sp in PCB */<BR>
    /* move PCB to ready queue */<BR>
    /* Schedule() */<BR>
}<BR>
</P></DIR>

</CODE><P>This interrupt will handle the yielding of a process. It leaves the stack of the yielding process with the address of <TT>Dispatch()</TT> on top. The role of <TT>Dispatch()</TT> is to pop all the register off, and restore the state of the yielded process, when this process is scheduled to run.</P>
<P>Note that when the yielded process is scheduled to run, the stack pointer will be reset to the value saved in the PCB of this yielded process. By calling the <TT>RETF</TT> assembly instruction, the CS and IP pointer to by the stack pointer will be loaded as the new CS and IP, and this will be the address of <TT>Dispatch()</TT>, which pops the registers and does an IRET instruction. The process then continues executing in <TT>System_service()</TT>, right where it left off, when it was yielding. <TT>System_service()</TT> then pops the registers (again; this is done automatically if it is an ``interrupt'' function) and returns to the process.</P>
<B><I><FONT FACE="Arial"><P>RETF vs. IRET </P>
</B></I></FONT><P>Calling <TT>RETF</TT> will cause the hardware to pop 4 bytes off the stack. The first two bytes will be placed in IP, and the second in CS. <TT>RETF</TT> stands for "far return" and is basically how a function returns to the function that called it. However, this mechanism can also be thought of as jumping directly to the address on the stack. Note that <TT>RETF</TT> does not care if the values on the stack are legitimate addresses. It will take the 4 bytes off the stack, stuff it in CS and IP, which effectively jumps to that address. Either you or the compiler are responsible for making sure the address is correct.</P>
<TT><P>IRET</TT> is typically called during a return from an interrupt. During an interrupt, the flags register, and the program counter (cs:ip) are pushed on the stack. <TT>IRET</TT> undoes this action by popping off 6 bytes. The first 4 bytes are still placed in CS and IP as before. The last 2 bytes are placed in the FLAGS register. This register records the interrupt status (enabled or disabled) as well as the status of the last instruction executed (typically, for use in branch instructions).</P>
<B><I><FONT FACE="Arial"><P><A NAME="SECTION00023000000000000000">Scheduler</A></P>
</B></I></FONT><P>The scheduler will use FIFO scheduling to determine the next process to run. Once the process has been chosen, it is added to the run queue and dispatched by loading ss:sp from the PCB and doing a RETF instruction.</P>
<P>The first time the scheduler is run, it should push the BP onto the stack, then save the SS and SP into static variables. Later, when it finds that there are no more processes to run, it should restore SS and SP from those variables, pop BP, and return. At that point, execution will resume in main after the call to schedule. You will write a function called <TT>Scheduler()</TT> to handle this. Place this in <TT>kernel.c</TT>.</P>
<B><I><FONT FACE="Arial"><P><A NAME="SECTION00024000000000000000">I/O</A></P>
</B></I></FONT><P>Since I/O operations are not implemented as system calls, no I/O-computation overlap will be achieved by this project. Nonetheless, you must use the keyboard and screen drivers from Project 1 to perform some I/O, or there would be no way to see your processes working. For <TT>Put_char()</TT>, the lack of an ``I/O wait'' state is of little consequence, since screen operations are memory-mapped. With <TT>Get_char()</TT>, however, the lack of the ``I/O wait'' state hurts performance. As in Project 1, <TT>Get_char()</TT> must not busy wait.</P>
<P>Without preemption, <TT>Get_char()</TT> and <TT>Put_char()</TT> can be used as desired without the need, for example, to exclude other processes when printing a line of characters. Likewise, a line of characters can be read in with confidence that they will be delivered to the same process.</P>
<B><I><FONT FACE="Arial"><P><A NAME="SECTION00025000000000000000">Kernel Initialization</A></P>
</B></I></FONT><P>The <TT>main()</TT> routine that you will write constitutes the kernel initialization code. A number of actions must be taken to set up the kernel. First, the interrupt vectors for the keyboard driver and kernel routines must be saved (i.e., the old DOS versions kept around), then re-vectored to the routines you have written. An initial process must be created, as described below. Finally, <TT>main()</TT> will invoke the scheduler.</P>
<P>The initial process, called <TT>Init()</TT>, is responsible for starting the other processes. <TT>Init()</TT> sets up the parameters for each process, invokes <TT>Proc_start()</TT> to start the other processes running, prints their process ID's with <TT>Cprintf()</TT> (which calls <TT>Put_char()</TT>), then terminates. Link with the file cmsc412.c in order to use a version of <TT>Cprintf()</TT> that calls your <TT>Put_char()</TT>.</P>
<P>Recall that <TT>Proc_start()</TT> will only create a PCB and the stack for a new process. You will still need to call the scheduler to start up the <TT>Init()</TT> process. <TT>Init()</TT> should take <TT>argc</TT> and <TT>argv</TT> as arguments. </P>
<B><FONT FACE="Arial" SIZE=4><P><A NAME="SECTION00030000000000000000">User Processes</A></P>
</B></FONT><P>All user processes, including the <TT>Init()</TT> process, should be included in a separate module titled <TT>proc.c</TT>. You can test your kernel by running a small number of processes concurrently, each of which first prints its arguments, then loops a small number of times. Each loop should produce a line of output that identifies the process for each loop iteration, then invokes <TT>Yield()</TT> to allow the next process to run.</P>
<P>We will test your programs by running your test routines, then by running our own <TT>Init()</TT> and a number (<B>&lt;</B> 10 concurrently) of other processes. Note that the names and parameters for the three system calls (<TT>Proc_start</TT>, etc.) must be designed as specified, or our test procedures will not run correctly.</P>
<B><FONT FACE="Arial" SIZE=4><P><A NAME="SECTION00040000000000000000">What to Turn In</A></P>
</B></FONT><P>Your diskette should have all files necessary for execution and compilation, and only these files, available on the root directory, including a makefile. The only specified file names for this project are <TT>makefile</TT> for the makefile and <TT>proc.c</TT> for your <TT>Init()</TT> and user processes.</P>
<B><FONT FACE="Arial" SIZE=4><P><A NAME="SECTION00050000000000000000">Some Important Stipulations</A></P>
</B></FONT><P>Your file <TT>proc.c</TT> MUST be compiled separately and linked with the kernel. Including <TT>proc.c</TT> in your kernel code is not acceptable. Also, your OS must create <TT>Init()</TT> as the initial process (using <TT>Proc_start()</TT> ). No other name may be used.</P>
<P>Comments and indentation are important. Make your code readable! Include a README file that lists the various files used, and a brief description of each of the functions used in each of the files. Also, add any comments that you feel the TA needs to know, especially where you feel there might be confusion, or where you have chosen to implement some part of your code in a different manner from the one specified.</P></BODY>
</HTML>
