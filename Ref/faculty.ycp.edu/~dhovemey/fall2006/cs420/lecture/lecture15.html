<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>CS 420 - Lecture 15</title>
</head>
<body>
<p>CS 420 - Lecture 15<br>
</p>
<p>[Finish up deadlock avoidance]<br>
</p>
<h2>Memory Management<br>
</h2>
<p>Characteristics of <span style="font-style: italic;">main memory</span>,
a.k.a. RAM:<br>
</p>
<p style="margin-left: 40px;">all code and data is stored in RAM (for
both the OS and the user processes)<br>
</p>
<p style="margin-left: 40px;">may be accessed fairly quickly: slower
than CPU registers but many thousands of times faster than disk<br>
</p>
<p style="margin-left: 40px;">volatile: turn of computer and contents
of main memory go away<br>
</p>
<p style="margin-left: 40px;">each byte of main memory has an <span
 style="font-style: italic;">physical address</span>: the entire set of
physical addresses is the <span style="font-style: italic;">physical
address space</span><br>
</p>
<p>Main memory is one of the most important resources that the OS
kernel must manage.&nbsp; Managing memory boils down to the problem of
dividing up memory and allocating it to the OS and user processes as
needed.<br>
</p>
<p style="margin-left: 40px;">Issue: memory protection.&nbsp; A user
process should only be able to access its own memory.&nbsp; It should
(ideally) never be able to access the memory of another process, or the
OS kernel, unless specifically allowed to.<br>
</p>
<p>Memory protection requires hardware support in the CPU.&nbsp;
Although it is possible to design an OS without hardware-enforced
memory protection, it is not desirable, because a misbehaving user
process can wreak all sorts of havoc on other processes and the OS
kernel.<br>
</p>
<h2>Segmentation and Logical Addresses<br>
</h2>
<p>The simplest hardware memory protection mechanism is <span
 style="font-style: italic;">segmentation</span>.&nbsp; Each user
process is allocated a contiguous chunk of main memory:<br>
</p>
<p style="margin-left: 40px;"><img alt=""
 src="figures/physAddrSpaceWithSegmentation.png" style="width: 40%;"><br>
</p>
<p>The CPU has two special registers: the <span
 style="font-style: italic;">base register</span> and the <span
 style="font-style: italic;">limit register</span>.&nbsp; Just before
switching control of the CPU to a user process, the kernel stores the
base address of the user process in the base register, and the size of
the user process's memory chunk into the limit register.<br>
</p>
<p>The base and limit registers thus define a logical address space for
the user process.&nbsp; Each memory reference that the process makes is
<span style="font-style: italic;">translated</span> to a physical
address according to the following procedure:<br>
</p>
<p style="margin-left: 40px;"><img alt="" src="figures/segmentation.png"
 style="width: 40%;"><br>
</p>
<p>Addresses generated by the program are <span
 style="font-style: italic;">logical addresses</span>.&nbsp; As far as
the process is concerned, it is executing in a logical address space
starting at logical address 0, and ending at logical address (limit-1).<br>
</p>
<p>Note that there is a state in this diagram marked "invalid logical
address".&nbsp; When this state occurs, it means that the process has
tried to access memory outside its own logical address space.&nbsp; The
CPU will generate a software interrupt that will return control to the
OS kernel, which will (most likely) terminate the process.<br>
</p>
<p>Note that whenever control switches from a user process to the
kernel, e.g. because of a system call, hardware device interrupt, or
any other kind of trap---the base register is set to 0 and the limit
register is set to the size of the physical address space.&nbsp; In
this way, the OS kernel can always access any address in physical
memory.<br>
</p>
<p>One nice property of segmentation is that when you write a program,
you do not need to know where in memory that program will be loaded
when it is actually executed.&nbsp; As long as the base register
reflects where the program is loaded, the program will have the
illusion that it is running in its own private logical address space.<br>
</p>
<p>A disadvantage of segmentation is that the memory allocated for a
process must be contiguous.&nbsp; If a process requires more memory
that it has currently been allocated, then it must be moved to a part
of main memory where a larger contiguous chunk is available.<br>
</p>
<h2>Paging<br>
</h2>
<p>A much more flexible scheme for hardware-enforced memory management
is <span style="font-style: italic;">paging</span>.<br>
</p>
<p>Memory is divided up into small chunks called <span
 style="font-style: italic;">pages</span>.&nbsp; On x86 CPUs, pages are
4K in size (where 1K = 4096 bytes).&nbsp; The start address of each
page must be an even multiple of the page size.<br>
</p>
<p>A physical memory page is sometimes called a <span
 style="font-style: italic;">frame</span>.<br>
</p>
<p>Paging allows the creation of <span style="font-style: italic;">virtual
address spaces</span>.&nbsp; Conceptually, a virtual address space is a
table specifying for each viritual page<br>
</p>
<p style="margin-left: 40px;">1. which physical page (frame) actually
stores the contents of that physical page, or<br>
</p>
<p style="margin-left: 40px;">2. that the virtual page is not mapped
(meaning that "nothing is there")<br>
</p>
<p style="margin-left: 40px;">3. that the data of the virtual page is
currently stored on disk<br>
</p>
<p>The data structures that define a virtual address space are the <span
 style="font-style: italic;">page tables</span>.<br>
</p>
<p>Example<br>
</p>
<p style="margin-left: 40px;"><img alt="" src="figures/pageTables.png"
 style="width: 20%;"><br>
</p>
<p>When paging is used, each virtual address is divided into two parts:
the page number, and the page offset within the page.<br>
</p>
<p>The hardware memory management unit, or MMU, translates the page
number to a physical frame number by looking up the entry in the page
tables.&nbsp; The frame number and the page offset are then combined to
form a physical address.<br>
</p>
<p style="margin-left: 40px;"><img alt="" src="figures/vaToPa.png"
 style="width: 50%;"><br>
</p>
<p>This system works because the page size is a multiple of two.&nbsp;
For example, on x86 CPUs, the page size is 4096, or 2^12 bytes.&nbsp;
That means the 12 low-order bits of a 32 bit virtual address are the
page offset, and the high-order 20 bits are the page number.<br>
</p>
<p>Paging gives the OS kernel complete flexibility to allocate memory
to processes.&nbsp; When a process needs some memory, the OS kernel
simply finds an available frame, and maps it into the process's page
tables.<br>
</p>
<p>Paging also allows the OS kernel to give memory to a process
lazily.&nbsp; THe process starts out with a virtual address space where
none of the entries in the page tables refer to a valid physical
address.&nbsp; When a process tries to access a virtual page for the
first time, the MMU causes an exception called a <span
 style="font-style: italic;">page fault</span>, which indicates that an
unmapped virtual address was accessed.&nbsp; To handle the page fault,
the OS kernel allocates a frame, maps it into the process's page
tables, and restarts the process so that the instruction that caused
the fault is re-executed.<br>
</p>
<p>Paging achieves memory protection because there is no way for a
process to access physical pages that are not mapped into its page
tables.<br>
</p>
<p>We have discussed the concept of virtual memory: using the disk as
second-level storage for physical memory, allowing processes to
continue running even when they require more memory than is actually
present as RAM.<br>
</p>
<h2>Hierarchical Page Tables</h2>
<p>Assume that the pages tables defining a virtual address space are
represented by a single table, with one entry for each virtual/physical
page pair.<br>
<br>
The index values correspond to virtual page numbers, so we don't need
to store the virtual page number in the entries.&nbsp; However, any
virtual page can map to an arbitrary frame, so we do need to store
frame numbers in the table.<br>
</p>
<p style="margin-left: 40px;">In reality, we will want to be able to
store a bit of extra information in each entry, but the main thing is
the frame number.<br>
</p>
<p>We know that there are 2^20 = 1,048,576 virtual page numbers in a
physical address space, assuming 32 bit addresses and 4K pages, like
the x86.&nbsp; Each entry in the table needs to store a frame number,
and assuming a 32 bit physical address space, there will be 2^20
possible frame numbers.&nbsp; Assuming that we are going to word-align
each entry, we need 4 byte for each table entry (with 12 bits in each
entry being available for other purposes).&nbsp; So, the entire table
is 4 * 2^20 = 2^22 = 4,194,304 bytes in size.<br>
</p>
<p>If we have to allocate a 4 MB data structure for each virtual
address space, that's going to chew up a lot of our main memory.<br>
</p>
<p>Solution: hierarchical page tables.&nbsp; [Next time.]<br>
</p>
</body>
</html>
