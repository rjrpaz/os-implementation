<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>CS 420 - Assignment 5</title>
</head>
<body>
<h1>CS 420 - Assignment 5<br>
</h1>
<p><span style="font-weight: bold;">Due Thursday, November 9th by 11:59
PM</span><br>
</p>
<h2>Virtual Memory, Part 1 (Bootstrapping)<br>
</h2>
<p>In this assignment you will start to implement support for virtual
memory in GeekOS by allocating a page directory and page tables to
define the kernel address space.<br>
</p>
<h3>Paging and Virtual Memory<br>
</h3>
<p>Recall that paging is the mechanism most often used to support
memory protection and virtual memory.&nbsp; To utilize the paging
hardware, the OS kernel builds an <span style="font-style: italic;">address
space</span> for each process, which is a map of virtual page numbers
to physical page (frame) numbers.&nbsp; An address space precisely
defines the mapping of virtual to physical addresses, giving the kernel
an easy way to enforce memory protection.<br>
</p>
<p>One easy to overlook consequence of using paging is that the OS
kernel must also use a page directory and page tables to define its <span
 style="font-weight: bold;">own</span> address space, because memory
references generated by the OS kernel go through virtual to physical
address translation, just like memory references generated by user
code.&nbsp; In other words, any memory accessible to the kernel must be
mapped into the kernel's address space.<br>
</p>
<h3>Bootstrapping<br>
</h3>
<p>One of the issues the kernel faces in defining its own address space
is how to <span style="font-style: italic;">bootstrap</span> paging
support.&nbsp; When a computer is turned on, it typically is running <span
 style="font-style: italic;">without</span> paging enabled, meaning
that there is no virtual to physical address translation.&nbsp; So,
prior to turning on the CPU's paging hardware, all memory references
made by the kernel resolve directly to physical addresses.<br>
</p>
<p>The bootstrapping problem arises when the kernel wants its code and
data loaded into a range of virtual addresses that do not correspond to
the range of physical addresses where it is initially loaded.&nbsp; One
solution to this problem is for the boot loader (the program that loads
the kernel) to build an initial set of page tables for the kernel, and
enable the paging hardware before any kernel code starts running.&nbsp;
Another (easier) solution is to define the range of virtual addresses
used by the kernel's code and data to correspond exactly to the
physical addresses where the kernel is loaded.<br>
</p>
<h3>Copyin and Copyout<br>
</h3>
<p>Another problem that the kernel must solve in managing its own
address space is how to support the <span style="font-style: italic;">copyin</span>
and <span style="font-style: italic;">copyout</span> operations:
copying data from a user-space buffer to a kernel buffer (copyin) and
copying data from a kernel buffer to a user-space buffer (copyout).<br>
</p>
<p>If the kernel address space is completely disjoint from each user
address space, then the kernel will have to temporarily add pages of
memory being used by a user process to its own address space before
copying.<br>
</p>
<p>A simpler strategy is to make the kernel's address space a part of
every user process address space: in other words, each process address
space contains all of the virtual to physical page mappings that
describe the kernel address space.&nbsp; (One way to do this is to have
the page directory for each user process address space contain a rage
of PDEs corresponding to the range of virtual addresses used by the
kernel address space; these PDEs all contain the frame numbers of the
set of page tables defining the kernel's address space.)&nbsp;
Page-level protection can then be used to prevent user code from
directly accessing any kernel memory.<br>
</p>
<p>The drawback of the simple strategy is that the kernel may need a
substantial chunk of the address space, reducing the range of virtual
addresses available to user processes.<br>
</p>
<h3>Virtual Memory in GeekOS<br>
</h3>
<p>There are many strategies for bootstrapping paging support and
organizing the kernel's address space.&nbsp; GeekOS uses an extremely
simple strategy.<br>
</p>
<p><span style="font-weight: bold;">Bootstrapping</span>: GeekOS loads
the kernel code and data into low physical memory (starting at address
10000H == 64K).&nbsp; The kernel address space in GeekOS is simply a
direct mapping of virtual addresses to physical addresses for the
entire range of physical memory.&nbsp; This scheme is fairly simple to
implement: paging is bootstrapped by building an initial page directory
and page tables setting up the direct virtual-&gt;physical
mapping&nbsp; This means that the GeekOS kernel running with paging
enabled works exactly like the GeekOS kernel running with paging turned
off: all memory references resolve to physical addresses.<br>
</p>
<p><span style="font-weight: bold;">Copyin/copyout</span>: GeekOS maps
the kernel address space into every user process address space.&nbsp;
This means that copyin and copyout can be done using a simple
memory-to-memory copy operation (e.g., the <span
 style="font-weight: bold;">memcpy</span> C function).<br>
</p>
<p>Because the kernel's region of each user address space covers the
low virtual addresses, the user memory must be mapped in high virtual
memory.&nbsp; GeekOS divides up the user address spaces in the
following way:<br>
</p>
<p style="margin-left: 40px;"><img alt=""
 src="figures/geekosAddressSpace.png" style="width: 60%;"><br>
</p>
<p>The virtual addresses in the range 0..2<sup>31</sup>-1 map directly
to
physical memory and may only be accessed by the kernel.&nbsp; The
virtual to physical mappings in this range are the same in every
address space.&nbsp; The virtual addresses in the range 2<sup>31</sup>..2<sup>32</sup>-1
are
available in each address space for the code, data, heap, and stack
memory used by the user process.<br>
</p>
<p>To preserve the illusion that user-accessible virtual addresses in
each address space start at zero, GeekOS makes use of the segmentation
hardware.&nbsp; Specifically, in each user process, the base and limit
registers are each set to 2<sup>31</sup> (2G), creating the illusion
that
user
addresses range from 0..2<sup>31</sup>-1.&nbsp; (This works because
memory
references made by user code <span style="font-style: italic;">first</span>
are translated by the segmentation hardware, and <span
 style="font-style: italic;">then</span> are translated by the paging
hardware.)<br>
</p>
<h2>Your Task<br>
</h2>
<p>Your task for this assignment is to build a kernel address space by
allocating and initializing a page directory and page tables creating a
direct mapping of virtual addresses to physical addresses for the
entire range of physical memory.<br>
</p>
<h3>Getting Started<br>
</h3>
<p>Start by downloading <a href="project2a.zip">project2a.zip</a>.&nbsp;
This is an enhanced
version of GeekOS that supports user processes and enforces memory
protection using segmentation.<br>
</p>
<p>If you are doing your development on cygwin, you will also need to
download a <a
 href="http://faculty.ycp.edu/%7Edhovemey/i386-elf-gcc.zip">special
version of the GNU development tools</a>.&nbsp; You should extract this
zip file in the root directory of your C: drive.&nbsp; When you start a
cygwin bash shell, execute the following command:<br>
</p>
<pre style="margin-left: 40px;">export PATH=/cygdrive/c/binutils-i386-elf/bin:$PATH<br></pre>
<p>This will allow the GeekOS makefile to find the updated development
tools.<br>
</p>
<h3>Page Directory and Page Tables<br>
</h3>
<p>Your task is to implement the <span style="font-weight: bold;">Init_VM()</span>
function in the file src/geekos/paging.c.<br>
</p>
<p>This function's sole responsibility is allocating and initializing a
page directory and page tables for the kernel address space.<br>
</p>
<p>Recall that the page directory and page tables are all one page in
size.&nbsp; In GeekOS, you can allocate a single frame of physical
memory using the Alloc_Page() function: for example:<br>
</p>
<pre style="margin-left: 40px;">g_kernelPageDir = Alloc_Page();<br></pre>
<p>would allocate a single (physical) page of memory and assign a
pointer to that memory to the g_kernelPageDir global variable.<br>
</p>
<p>The page directory is simply an array of page directory
entries.&nbsp; A page directory entry in GeekOS is a value whose type
is <span style="font-weight: bold;">pde_t</span>.&nbsp; You can see
the definition of this type in the header file <span
 style="font-weight: bold;">include/geekos/paging.h</span>:<br>
</p>
<pre style="margin-left: 40px;">/*<br> * Page directory entry datatype.<br> * If marked as present, it specifies the physical address<br> * and permissions of a page table.<br> */<br>typedef struct {<br>    uint_t present:1;<br>    uint_t flags:4;<br>    uint_t accesed:1;<br>    uint_t reserved:1;<br>    uint_t largePages:1;<br>    uint_t globalPage:1;<br>    uint_t kernelInfo:3;<br>    uint_t pageTableBaseAddr:20;<br>} pde_t;<br></pre>
<p>Each field of the <span style="font-weight: bold;">pde_t </span>type
represents a range of bits in a page directory entry.&nbsp; (You may
find it useful to look at the <a
 href="http://faculty.ycp.edu/%7Edhovemey/fall2006/cs420/lecture/lecture16.html">notes
for lecture 16</a>, which describes how paging works in the x86
architecture.)&nbsp; For example, the <span style="font-weight: bold;">present</span>
field corresponds to the <span style="font-weight: bold;">p</span> bit
that specifies whether a particular PDE has the frame number of a valid
page table (1 means that it does, 0 means that it doesn't.)<br>
</p>
<p>You will need to set each of the 1024 entries in the page directory
to either<br>
</p>
<p style="margin-left: 40px;">(1) Refer to a valid page table, or<br>
</p>
<p style="margin-left: 40px;">(2) Indicate that the range of virtual
addresses covered by the page table entry is not mapped<br>
</p>
<p>Because the kernel's address space is simply a direct map of
physical memory, you only need to add PDEs for the amount of physical
memory that is installed.&nbsp; You can find this information in the
Boot_Info structure that is passed to the <span
 style="font-weight: bold;">Init_VM()</span> function:<br>
</p>
<pre style="margin-left: 40px;">bootInfo-&gt;memSizeKB<br></pre>
<p>indicates the amount of installed physical memory in kilobytes.<br>
</p>
<p>You can start out by clearing all of the page directory entries:<br>
</p>
<pre style="margin-left: 40px;">memset(g_kernelPageDir, '\0', 4096);<br></pre>
<p>This will ensure that each entry in the page directory is initially
unmapped.<br>
</p>
<p>Let's say you want to make a single page directory entry point to a
freshly allocated empty page table.&nbsp; Here's how you would do this
for page directory entry 1, which covers the range of virtual addresses
from 4,194,304 (4M) to 8,388,608 (8M):<br>
</p>
<pre style="margin-left: 40px;">{<br>    pte_t *pageTable;<br>    pde_t entry = {0};<br><br>    /* Allocate a page table and clear it */<br>    pageTable = Alloc_Page();<br>   &nbsp;memset(pageTable, '\0', 4096);<br><br>    /* Create a page directory entry pointing to this page table */<br>    entry.present = 1;<br>    entry.flags = VM_USER | VM_WRITE;<br>    entry.pageTableBaseAddr = ((ulong_t) pageTable)) &gt;&gt; 12;<br><br>    /* Install the PDE in index 1 of the page directory */<br>    g_kernelPageDir[1] = entry;<br>}<br></pre>
<p>You will need to install PDEs for each range of physical memory, up
to the amount of physical memory indicated by
bootInfo-&gt;memSizeKB.&nbsp; Each PDE will need to have its own
freshly allocated page table.<br>
</p>
<p>Once the page directory has been fully prepared with page tables for
each range of physical addresses, you will need to install page table
entries (PTEs) in each page table.&nbsp; In GeekOS, PTEs are
represented by the <span style="font-weight: bold;">pte_t</span> data
type, also defined in <span style="font-weight: bold;">include/geekos/paging.h</span>:<br>
</p>
<pre style="margin-left: 40px;">/*<br> * Page table entry datatype.<br> * If marked as present, it specifies the physical address<br> * and permissions of a page of memory.<br> */<br>typedef struct {<br>    uint_t present:1;<br>    uint_t flags:4;<br>    uint_t accesed:1;<br>    uint_t dirty:1;<br>    uint_t pteAttribute:1;<br>    uint_t globalPage:1;<br>    uint_t kernelInfo:3;<br>    uint_t pageBaseAddr:20;<br>} pte_t;<br></pre>
<p>The structure is almost exactly the same as <span
 style="font-weight: bold;">pde_t</span>.&nbsp; A page table is an
array whose element type is <span style="font-weight: bold;">pte_t</span>.&nbsp;
There are 1024 entries in a page table, same as the number of entries
in a page directory.<br>
</p>
<p>Recall that PDE 1 covers the range of memory addresses starting at
4,194,304 (4M).&nbsp; That means that the first PTE (index 0) in the
page table we installed in the code example above should map to the
frame whose physical address is 4,194,304.&nbsp; We could use the
following code to install that PTE:<br>
</p>
<pre style="margin-left: 40px;">{<br>    /* Get a pointer to the page table pointed to by PDE 1 */<br>    pte_t *pageTable = (pte_t *) (g_kernelPageDir[1].pageTableBaseAddr &lt;&lt; 12);<br><br>    pte_t entry = {0};<br><br>    entry.present = 1;<br>    entry.flags = VM_USER | VM_WRITE;<br>    entry.pageBaseAddr = (4194304U &gt;&gt; 12);<br>}<br></pre>
<p>Your task boils down to making sure that each PDE and each PTE are
set up properly.&nbsp; You will need to generalize the examples above
to figure out how to initialize each PDE and each PTE.<br>
</p>
<p>Once your page directory and page tables have been completely
initialized, you can turn on the paging hardware as follows:<br>
</p>
<pre style="margin-left: 40px;">Enable_Paging(g_kernelPageDir);<br></pre>
<p>The very last thing you should do is register the handler for the
page fault interrupt:<br>
</p>
<pre style="margin-left: 40px;">/* Install the page fault handler */<br>Install_Interrupt_Handler(14, Page_Fault_Handler);<br></pre>
<p>In later projects you will be able to use the page fault handler to
implement a full virtual memory system, but for now it will not do
anything.<br>
</p>
<p>Assuming all goes well, you should be able to run Bochs and boot
into a functioning GeekOS system.&nbsp; The GeekOS disk image will
contain a command interpreter (shell) and several executable
programs.&nbsp; Here is a screenshot showing how to run several of
these programs:<br>
</p>
<p style="margin-left: 40px;"><img alt=""
 src="figures/project2aScreenshot.png"
 style="width: 730px; height: 493px;"><br>
</p>
<h2>Hints and Tips<br>
</h2>
<p>Use "make -j 2" to compile faster (taking advantage of hyperthreaded
or multicore CPUs).<br>
</p>
<p>You will probably need to edit the "bochsrc.txt" file in the build
directory so that the romimage and vgaromimage correctly refer to the
directory in which you installed Bochs.<br>
</p>
<h2>Submitting<br>
</h2>
<p>Submit a zip file containing your entire <span
 style="font-weight: bold;">project2a</span> directory to the My YCP
Inbox for Assignment 5.&nbsp; (Please do a "make clean" first.)<br>
</p>
</body>
</html>
